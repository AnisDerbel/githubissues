{"version":3,"sources":["utils.js"],"names":["htmlparser2","require","domhandler","exports","isTag","DomUtils","camelCase","str","replace","_","x","toUpperCase","cssCase","toLowerCase","domEach","cheerio","fn","i","len","length","call","cloneDom","dom","clone","Array","prototype","map","el","cloneNode","root","Document","forEach","node","parent","quickExpr","isHtml","charAt","match","exec"],"mappings":"AAAA,IAAIA,WAAW,GAAGC,OAAO,CAAC,aAAD,CAAzB;;AACA,IAAIC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAAxB;;AAYAE,OAAO,CAACC,KAAR,GAAgBJ,WAAW,CAACK,QAAZ,CAAqBD,KAArC;;AAUAD,OAAO,CAACG,SAAR,GAAoB,UAAUC,GAAV,EAAe;AACjC,SAAOA,GAAG,CAACC,OAAJ,CAAY,cAAZ,EAA4B,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACjD,WAAOA,CAAC,CAACC,WAAF,EAAP;AACD,GAFM,CAAP;AAGD,CAJD;;AAeAR,OAAO,CAACS,OAAR,GAAkB,UAAUL,GAAV,EAAe;AAC/B,SAAOA,GAAG,CAACC,OAAJ,CAAY,QAAZ,EAAsB,KAAtB,EAA6BK,WAA7B,EAAP;AACD,CAFD;;AAcAV,OAAO,CAACW,OAAR,GAAkB,UAAUC,OAAV,EAAmBC,EAAnB,EAAuB;AACvC,MAAIC,CAAC,GAAG,CAAR;AACA,MAAIC,GAAG,GAAGH,OAAO,CAACI,MAAlB;;AACA,SAAOF,CAAC,GAAGC,GAAJ,IAAWF,EAAE,CAACI,IAAH,CAAQL,OAAR,EAAiBE,CAAjB,EAAoBF,OAAO,CAACE,CAAD,CAA3B,MAAoC,KAAtD;AAA6D,MAAEA,CAAF;AAA7D;;AACA,SAAOF,OAAP;AACD,CALD;;AAcAZ,OAAO,CAACkB,QAAR,GAAmB,UAAUC,GAAV,EAAe;AAChC,MAAIC,KAAK,GACP,YAAYD,GAAZ,GACIE,KAAK,CAACC,SAAN,CAAgBC,GAAhB,CAAoBN,IAApB,CAAyBE,GAAzB,EAA8B,UAAUK,EAAV,EAAc;AAC1C,WAAOzB,UAAU,CAAC0B,SAAX,CAAqBD,EAArB,EAAyB,IAAzB,CAAP;AACD,GAFD,CADJ,GAII,CAACzB,UAAU,CAAC0B,SAAX,CAAqBN,GAArB,EAA0B,IAA1B,CAAD,CALN;AAQA,MAAIO,IAAI,GAAG,IAAI3B,UAAU,CAAC4B,QAAf,CAAwBP,KAAxB,CAAX;AACAA,EAAAA,KAAK,CAACQ,OAAN,CAAc,UAAUC,IAAV,EAAgB;AAC5BA,IAAAA,IAAI,CAACC,MAAL,GAAcJ,IAAd;AACD,GAFD;AAIA,SAAON,KAAP;AACD,CAfD;;AAoBA,IAAIW,SAAS,GAAG,yCAAhB;;AASA/B,OAAO,CAACgC,MAAR,GAAiB,UAAU5B,GAAV,EAAe;AAE9B,MACEA,GAAG,CAAC6B,MAAJ,CAAW,CAAX,MAAkB,GAAlB,IACA7B,GAAG,CAAC6B,MAAJ,CAAW7B,GAAG,CAACY,MAAJ,GAAa,CAAxB,MAA+B,GAD/B,IAEAZ,GAAG,CAACY,MAAJ,IAAc,CAHhB,EAIE;AACA,WAAO,IAAP;AACD;;AAGD,MAAIkB,KAAK,GAAGH,SAAS,CAACI,IAAV,CAAe/B,GAAf,CAAZ;AACA,SAAO,CAAC,EAAE8B,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAhB,CAAR;AACD,CAbD","sourcesContent":["var htmlparser2 = require('htmlparser2');\nvar domhandler = require('domhandler');\n\n/**\n * Check if the DOM element is a tag.\n *\n * `isTag(type)` includes `<script>` and `<style>` tags.\n *\n * @param {node} type - DOM node to check.\n * @returns {boolean}\n *\n * @private\n */\nexports.isTag = htmlparser2.DomUtils.isTag;\n\n/**\n * Convert a string to camel case notation.\n *\n * @param  {string} str - String to be converted.\n * @returns {string}      String in camel case notation.\n *\n * @private\n */\nexports.camelCase = function (str) {\n  return str.replace(/[_.-](\\w|$)/g, function (_, x) {\n    return x.toUpperCase();\n  });\n};\n\n/**\n * Convert a string from camel case to \"CSS case\", where word boundaries are\n * described by hyphens (\"-\") and all characters are lower-case.\n *\n * @param  {string} str - String to be converted.\n * @returns {string}      String in \"CSS case\".\n *\n * @private\n */\nexports.cssCase = function (str) {\n  return str.replace(/[A-Z]/g, '-$&').toLowerCase();\n};\n\n/**\n * Iterate over each DOM element without creating intermediary Cheerio\n * instances.\n *\n * This is indented for use internally to avoid otherwise unnecessary memory\n * pressure introduced by _make.\n *\n * @param {cheerio} cheerio - Cheerio object.\n * @param {Function} fn - Function to call.\n */\nexports.domEach = function (cheerio, fn) {\n  var i = 0;\n  var len = cheerio.length;\n  while (i < len && fn.call(cheerio, i, cheerio[i]) !== false) ++i;\n  return cheerio;\n};\n\n/**\n * Create a deep copy of the given DOM structure.\n * Sets the parents of the copies of the passed nodes to `null`.\n *\n * @param {object} dom - The htmlparser2-compliant DOM structure.\n * @private\n */\nexports.cloneDom = function (dom) {\n  var clone =\n    'length' in dom\n      ? Array.prototype.map.call(dom, function (el) {\n          return domhandler.cloneNode(el, true);\n        })\n      : [domhandler.cloneNode(dom, true)];\n\n  // Add a root node around the cloned nodes\n  var root = new domhandler.Document(clone);\n  clone.forEach(function (node) {\n    node.parent = root;\n  });\n\n  return clone;\n};\n\n/*\n * A simple way to check for HTML strings or ID strings\n */\nvar quickExpr = /^(?:[^#<]*(<[\\w\\W]+>)[^>]*$|#([\\w-]*)$)/;\n\n/**\n * Check if string is HTML.\n *\n * @param {string} str - String to check.\n *\n * @private\n */\nexports.isHtml = function (str) {\n  // Faster than running regex, if str starts with `<` and ends with `>`, assume it's HTML\n  if (\n    str.charAt(0) === '<' &&\n    str.charAt(str.length - 1) === '>' &&\n    str.length >= 3\n  ) {\n    return true;\n  }\n\n  // Run the regex\n  var match = quickExpr.exec(str);\n  return !!(match && match[1]);\n};\n"]}